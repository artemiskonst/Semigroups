############################################################################
##
##  congruences/congpairs.gi
##  Copyright (C) 2015-2021                               Michael C. Young
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##
## This file contains functions for any congruence of a semigroup with
## generating pairs.
#############################################################################

InstallImmediateMethod(GeneratingPairsOfAnyCongruence,
                       IsCongruenceCategory
                         and HasGeneratingPairsOfMagmaCongruence,
                       0,
                       GeneratingPairsOfMagmaCongruence);

InstallImmediateMethod(GeneratingPairsOfAnyCongruence,
                       IsLeftCongruenceCategory
                         and HasGeneratingPairsOfLeftMagmaCongruence,
                       0,
                       GeneratingPairsOfLeftMagmaCongruence);

InstallImmediateMethod(GeneratingPairsOfAnyCongruence,
                       IsRightCongruenceCategory
                         and HasGeneratingPairsOfRightMagmaCongruence,
                       0,
                       GeneratingPairsOfRightMagmaCongruence);

#############################################################################
# Constructor
#############################################################################

InstallMethod(_AnyCongruenceByGeneratingPairs,
[IsSemigroup, IsHomogeneousList, IsFunction],
function(S, pairs, filt)
  local fam, C, pair;

  for pair in pairs do
    if not IsList(pair) or Length(pair) <> 2 then
      Error("the 2nd argument <pairs> must consist of lists of ",
            "length 2");
    elif not pair[1] in S or not pair[2] in S then
      Error("the 2nd argument <pairs> must consist of lists of ",
            "elements of the 1st argument <S> (a semigroup)");
    fi;
  od;

  # Create the Object
  fam := GeneralMappingsFamily(ElementsFamily(FamilyObj(S)),
                               ElementsFamily(FamilyObj(S)));

  C := Objectify(NewType(fam, filt and IsAttributeStoringRep),
                 rec());
  SetSource(C, S);
  SetRange(C, S);
  if IsCongruenceCategory(C) then
    SetGeneratingPairsOfMagmaCongruence(C, pairs);
  elif IsLeftCongruenceCategory(C) then
    SetGeneratingPairsOfLeftMagmaCongruence(C, pairs);
  elif IsRightCongruenceCategory(C) then
    SetGeneratingPairsOfRightMagmaCongruence(C, pairs);
  else
    Error("Something has gone wrong, should not have ",
          "been able to reach here!");
  fi;
  return C;
end);

#############################################################################
# Properties of congruences
#############################################################################

InstallMethod(IsRightSemigroupCongruence,
"for a left semigroup congruence with known generating pairs",
[IsLeftSemigroupCongruence and HasGeneratingPairsOfLeftMagmaCongruence],
function(congl)
  local pairs, cong2;
  # Is this left congruence right-compatible?
  # First, create the 2-sided congruence generated by these pairs.
  pairs := GeneratingPairsOfLeftSemigroupCongruence(congl);
  cong2 := SemigroupCongruence(Range(congl), pairs);

  # congl is right-compatible iff these describe the same relation
  if congl = cong2 then
    SetGeneratingPairsOfMagmaCongruence(congl, pairs);
    SetIsSemigroupCongruence(congl, true);
    return true;
  else
    SetIsSemigroupCongruence(congl, false);
    return false;
  fi;
end);

InstallMethod(IsLeftSemigroupCongruence,
"for a right semigroup congruence with known generating pairs",
[IsRightSemigroupCongruence and HasGeneratingPairsOfRightMagmaCongruence],
function(congr)
  local pairs, cong2;
  # Is this right congruence left-compatible?
  # First, create the 2-sided congruence generated by these pairs.
  pairs := GeneratingPairsOfRightSemigroupCongruence(congr);
  cong2 := SemigroupCongruence(Range(congr), pairs);

  # congr is left-compatible iff these describe the same relation
  if congr = cong2 then
    SetGeneratingPairsOfMagmaCongruence(congr, pairs);
    SetIsSemigroupCongruence(congr, true);
    return true;
  else
    SetIsSemigroupCongruence(congr, false);
    return false;
  fi;
end);

InstallMethod(IsSemigroupCongruence,
"for a left semigroup congruence with known generating pairs",
[IsLeftSemigroupCongruence and HasGeneratingPairsOfLeftMagmaCongruence],
IsRightSemigroupCongruence);

InstallMethod(IsSemigroupCongruence,
"for a right semigroup congruence with known generating pairs",
[IsRightSemigroupCongruence and HasGeneratingPairsOfRightMagmaCongruence],
IsLeftSemigroupCongruence);

#############################################################################
# Printing and viewing of congruences
#############################################################################

InstallMethod(PrintObj,
"for IsAnyCongruenceCategory with known generating pairs",
[IsAnyCongruenceCategory and HasGeneratingPairsOfAnyCongruence],
function(cong)
  local string;

  if not IsCongruenceCategory(cong) then
    string := ShallowCopy(AnyCongruenceString(cong));
    string[1] := UppercaseChar(string[1]);
  else
    string := "";
  fi;

  Print(string, "SemigroupCongruence( ");
  PrintObj(Range(cong));
  Print(", ");
  Print(GeneratingPairsOfAnyCongruence(cong));
  Print(" )");
end);

# HERE

InstallMethod(ViewObj,
"for a left semigroup congruence",
[IsLeftSemigroupCongruence and HasGeneratingPairsOfLeftMagmaCongruence],
function(cong)
  Print("<left semigroup congruence over ");
  ViewObj(Range(cong));
  Print(" with ",
        Size(GeneratingPairsOfLeftSemigroupCongruence(cong)),
        " generating pairs>");
end);

InstallMethod(ViewObj,
"for a right semigroup congruence",
[IsRightSemigroupCongruence and HasGeneratingPairsOfRightMagmaCongruence],
function(cong)
  Print("<right semigroup congruence over ");
  ViewObj(Range(cong));
  Print(" with ",
        Size(GeneratingPairsOfRightSemigroupCongruence(cong)),
        " generating pairs>");
end);

InstallMethod(ViewObj,
"for a semigroup congruence",
[IsSemigroupCongruence and HasGeneratingPairsOfMagmaCongruence],
function(cong)
  Print("<semigroup congruence over ");
  ViewObj(Range(cong));
  Print(" with ",
        Size(GeneratingPairsOfSemigroupCongruence(cong)),
        " generating pairs>");
end);

########################################################################
# Comparison operators
########################################################################

InstallMethod(\=,
"for IsAnyCongruenceCategory and HasGeneratingPairsOfAnyCongruence",
[IsAnyCongruenceCategory and HasGeneratingPairsOfAnyCongruence,
 IsAnyCongruenceCategory and HasGeneratingPairsOfAnyCongruence],
function(c1, c2)
  if AnyCongruenceCategory(c1) = AnyCongruenceCategory(c2) then
    return Range(c1) = Range(c2)
           and ForAll(GeneratingPairsOfAnyCongruence(c1), pair -> pair in c2)
           and ForAll(GeneratingPairsOfAnyCongruence(c2), pair -> pair in c1);
  fi;
  TryNextMethod();
end);

InstallMethod(IsSubrelation,
"for IsAnyCongruenceCategory and HasGeneratingPairsOfAnyCongruence",
[IsAnyCongruenceCategory and HasGeneratingPairsOfAnyCongruence,
 IsAnyCongruenceCategory and HasGeneratingPairsOfAnyCongruence],
function(c1, c2)
  # Only valid for certain combinations of types
  if AnyCongruenceCategory(c1) <> AnyCongruenceCategory(c2)
      and AnyCongruenceCategory(c1) <> IsCongruenceCategory then
    TryNextMethod();
  elif Range(c1) <> Range(c2) then
    Error("the 1st and 2nd arguments are congruences over different",
          " semigroups");
  fi;

  # Test whether c1 contains all the pairs in c2
  return ForAll(GeneratingPairsOfAnyCongruence(c2),
                pair -> CongruenceTestMembershipNC(c1, pair[1], pair[2]));
end);

########################################################################
# Algebraic operators
########################################################################

BindGlobal("JoinAnyCongruences",
function(lhop, rhop)
  local Constructor, pairs;
  if Range(lhop) <> Range(rhop) then
    Error("cannot form the join of congruences over different semigroups");
  elif AnyCongruenceCategory(lhop) <> AnyCongruenceCategory(rhop) then
    Error("cannot form the join of congruences of different handedness");
  elif lhop = rhop then
    return lhop;
  fi;

  if IsCongruenceCategory(lhop) then
    Constructor := SemigroupCongruenceByGeneratingPairs;
  elif IsLeftCongruenceCategory(lhop) then
    Constructor := LeftSemigroupCongruenceByGeneratingPairs;
  else
    Assert(1, IsRightCongruenceCategory(lhop));
    Constructor := RightSemigroupCongruenceByGeneratingPairs;
  fi;
  pairs := Concatenation(ShallowCopy(GeneratingPairsOfAnyCongruence(lhop)),
                         ShallowCopy(GeneratingPairsOfAnyCongruence(rhop)));
  return Constructor(Range(lhop), pairs);
end);

InstallMethod(JoinSemigroupCongruences,
"for a semigroup congruence with known generating pairs",
[IsCongruenceCategory and HasGeneratingPairsOfMagmaCongruence,
 IsCongruenceCategory and HasGeneratingPairsOfMagmaCongruence],
JoinAnyCongruences);

InstallMethod(JoinLeftSemigroupCongruences,
"for a semigroup left congruence with known generating pairs",
[IsLeftCongruenceCategory and HasGeneratingPairsOfLeftMagmaCongruence,
 IsLeftCongruenceCategory and HasGeneratingPairsOfLeftMagmaCongruence],
JoinAnyCongruences);

InstallMethod(JoinRightSemigroupCongruences,
"for a semigroup Right congruence with known generating pairs",
[IsRightCongruenceCategory and HasGeneratingPairsOfRightMagmaCongruence,
 IsRightCongruenceCategory and HasGeneratingPairsOfRightMagmaCongruence],
JoinAnyCongruences);
